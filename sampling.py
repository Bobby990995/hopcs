import numpy as np
from math import ceil, log
from fractions import gcd
import matplotlib.pyplot as plt

def autocorrelation (r_xx, x1, x2, zero):
    """
    Calculate the autocorrelation operating upon the r_xx.
    Return the modified array of autocorrelation.
    Input:  r_xx: previous autocorrelation.
            x1, x2: co-prime sampled signal.
            zero: relative zero point along with moving window.
    """
    for i in range(len(x1)):
        if x1[i][1] == 0:
            continue
        for j in range(len(x2)):
            if x2[j][1] == 0:
                continue
            index = abs(x1[i][0]-x2[j][0])
            #if index > 255:
            #    continue
            if zero+index < len(r_xx):
                index += zero
                if r_xx[index][1] == 0:
                    r_xx[index][0] = x1[i][1]*(x2[j][1].conj())
                    r_xx[index][1] += 1
                else:
                    r_xx[index][0] = (r_xx[index][1]*r_xx[index][0] + x1[i][1]*(x2[j][1].conj())) / (r_xx[index][1]+1)
                    r_xx[index][1] += 1
    return r_xx

def dft (r_xx, Fs, NFFT, hamming, overlap=True, sides='default'):
    if overlap:
        step = NFFT // 2
    else:
        step = NFFT
    ind = np.arange(0, len(r_xx)-NFFT+ 1, step)
    n = len(ind)
    pad_to = NFFT
    if (sides == 'default' and np.iscomplexobj(r_xx)) or sides == 'twosided':
        numFreqs = pad_to
        scaling_factor = 1.
    elif sides in ('default', 'onesided'):
        numFreqs = pad_to//2 + 1
        scaling_factor = 2.
    else:
        raise ValueError("sides must be one of: 'default', 'onesided', or 'twosided'")
    
    psd = np.zeros((numFreqs, n), np.complex_)
    
    for i in range(n):
        temp = r_xx[ind[i]:(ind[i]+NFFT),0]*hamming
        psd[:,i] = np.fft.fft(temp, n=pad_to)[:numFreqs]
        #psd[:,i] = np.conjugate(fx[:numFreqs])*fx[:numFreqs]
    
    # Also include scaling factors for one-sided densities and dividing by the
    # sampling frequency, if desired. Scale everything, except the DC component
    # and the NFFT/2 component:
    psd[1:-1] *= scaling_factor

    # MATLAB divides by the sampling frequency so that density function
    # has units of dB/Hz and can be integrated by the plotted frequency
    # values. Perform the same scaling here.
    psd /= Fs
    
    t = 1./Fs * (ind + NFFT/2.)
    freqs = float(Fs) / pad_to * np.arange(numFreqs)

    if (np.iscomplexobj(r_xx) and sides == 'default') or sides == 'twosided':
        # center the frequency range at zero
        freqs = np.concatenate((freqs[numFreqs//2:] - Fs, freqs[:numFreqs//2]))
        psd = np.concatenate((psd[numFreqs//2:, :], psd[:numFreqs//2, :]), 0)

    return psd, freqs, t

def visualize_rxx (r_xx, Fs, NFFT):
    step = NFFT
    ind = np.arange(0, len(r_xx)-NFFT+ 1, step)
    n = len(ind)
    pad_to = NFFT
    numFreqs = NFFT//2+1
    psd = np.zeros((numFreqs, n), np.complex_)
    t = 1./Fs * (ind + NFFT/2.)
    freqs = float(Fs) / pad_to * np.arange(numFreqs)
    for i in range(n):
        psd[:,i] = r_xx[ind[i]:(ind[i]+NFFT),0][:numFreqs]
    return psd, freqs, t

def test_coprime (input):
    if len(input)<=1: return False
    for i in range(len(input)):
        if input[i]<=0: return False
        for j in range(i+1, len(input)):
            if gcd(input[i],input[j])!=1: return False
    return True

def sampling (signal, n1, n2, zero):
    """
    Return the co-prime sampled signals.
    The format of return values is a 2-d matrix:
        (index in original signal, signal value)
    Input:  signal values (1-d vector)
            n1, n2: the relative sampling points generated by coprime pairs
            zero: relative zero point along with moving window.
    """
    x1 = np.array([[zero+n1[i], signal[zero+n1[i]]] for i in range(len(n1)) if zero+n1[i]<len(signal)])
    x2 = np.array([[zero+n2[i], signal[zero+n2[i]]] for i in range(len(n2)) if zero+n2[i]>=0 and zero+n2[i]<len(signal)])
    return x1, x2

def main (file, NFFT, coprime_list):
    # preprocessing
    assert test_coprime(coprime_list), "The input coprime list is illegal."
    coprime_list.sort()
   
    signal = np.load(file)
    steps = int(ceil(len(signal)/float(NFFT)))
    print "The length of signal is ", len(signal)
    print "...And it is splitted into %d pieces" % (steps)
    
    product = reduce(lambda x,y: x*y, coprime_list)
    if product > NFFT:
        print "Warning: There might be blind spots in a FFT segmentation"

    index = {}
    sampled = {}
    for i in range(len(coprime_list)):
        index[i] = np.sort([j+k*NFFT for j in xrange(0,NFFT,coprime_list[i]) for k in range(steps)])
        sampled[i] = np.array([[signal[j],j] for j in index[i]])
        print "For this slot, the length of sampled sequence is ", len(index[i])
        print len(sampled[i])


    # r_xx with the same length of signal to store and average estimations
    # 1st column is the value of autocorrelation
    # 2nd column is the # of sample points contribute to this autocorrelation
#    r2 = r3 = r4 = np.zeros((len(signal),2))
#    overlap = False
#    hamming = np.hamming(NFFT)
#
#    in_step = 0
#    for i in range(steps):
#        # the relative zero point for the current window
#        zero = i*NFFT
#        # slicing the signal and conduct co-prime sampling 
#        x0 = np.zeros((len(n0)*num_cell,2))
#        x1 = np.zeros((len(n1)*num_cell,2))
#        while in_step < num_cell:
#            temp1, temp2 = sampling(signal, n1, n2, zero+in_step*k)
#            if len(temp1) != 0:
#                x1[in_step*N:in_step*N+len(temp1),:] = temp1
#            if len(temp2) != 0:
#                x2[in_step*M:in_step*M+len(temp2),:] = temp2
#            in_step += 1
#        r_xx = autocorrelation(r_xx, x1, x2, zero)
#        in_step = 0
#
#    if output == 'psd':
#        psd, freq, time = dft(r_xx, Fs, NFFT, hamming, overlap)
#    elif output == 'autocorrelation':
#        psd, freq, time = visualize_rxx(r_xx, Fs, NFFT)
#    else:
#        raise ValueError("The output definition is incorrect (psd or autocorrelation).")
#    #psd = plot_contour(time, freq, psd)
#    return abs(psd), freq, time


